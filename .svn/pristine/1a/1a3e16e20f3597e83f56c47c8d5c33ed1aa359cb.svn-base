package com.docprocess.service.impl;

import com.docprocess.model.DocumentGenerateQueueData;
import com.docprocess.model.PAMain;
import com.docprocess.pojo.DocumentSignRequest;
import com.docprocess.pojo.DocumentSignResponse;
import com.docprocess.pojo.TokenResponse;
//import com.docprocess.pojo.repository.DocumentDataRepository;
//import com.docprocess.pojo.repository.PAMainRepository;
import com.docprocess.repository.DocumentDataRepository;
import com.docprocess.repository.PAMainRepository;
import com.docprocess.service.ApiSigningService;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.commons.text.StringEscapeUtils;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.converter.FormHttpMessageConverter;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestTemplate;

import java.io.IOException;
import java.text.MessageFormat;
import java.time.Duration;
import java.time.Instant;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

public class ApiSigningServiceImpl implements ApiSigningService {
    private static final String PLAN_ID = "OB001";
    private static final String CACHE_TOKEN_EXPIRE_AT = "tokenExpireAt";
    private static final String CACHE_ACCESS_TOKEN = "accessToken";
    private static final String CACHE_ACCESS_TOKEN_TYPE = "accessTokenType";

    private static final String AUTHORIZATION_HEADER = "Authorization";

    private final static String GRANT_TYPE = "client_credentials";
    private final static String SCOPE = "IFile-Gateway";
    private final static String POLICY_TYPE = "Individual";
    private static final String APPLICATION_NAME = "Roojai";

    private final String clientId;
    private final String clientSecret;
    private final String tokenEndpoint;
    private final String documentEndpoint;
    private final DocumentDataRepository documentDataRepository;
    private final PAMainRepository paRepository;

    private final Map<String, Object> cache = new HashMap<>();

    public ApiSigningServiceImpl(
            String clientSecret,
            String clientId,
            String tokenEndpoint,
            String documentEndpoint,
            DocumentDataRepository documentDataRepository,
            PAMainRepository paRepository) {
        this.tokenEndpoint = tokenEndpoint;
        this.documentEndpoint = documentEndpoint;
        this.clientId = clientId;
        this.clientSecret = clientSecret;
        this.documentDataRepository = documentDataRepository;
        this.paRepository = paRepository;
    }

    @Override
    public byte[] signDocument(byte[] input, String documentSfid) throws IOException {
        // Get signing info from table fmsapp.document_data
        DocumentGenerateQueueData docData = documentDataRepository.findBySfid(documentSfid);
        PAMain paMainInfo = paRepository.findById(docData.getReferenceNumber()).orElse(null);

        if (paMainInfo == null || paMainInfo.getTransactedDate() == null || paMainInfo.getInsurerPolicyNo() == null) {
            return null;
        }

        // Check if cached token had expired or not if expired refresh for new access token
        String accessToken = getCacheAccessToken()
                .orElseGet(() -> {
                    TokenResponse tokenResponse = authenticate(clientId, clientSecret);
                    return tokenResponse.getAccessToken();
                });
        String authorizationHeader = MessageFormat.format("{0} {1}", cache.get(CACHE_ACCESS_TOKEN_TYPE), accessToken);

        LocalDate ld = LocalDate.parse(paMainInfo.getTransactedDate(), DateTimeFormatter.ofPattern("dd/MM/yyyy"));
        DocumentSignRequest documentSignRequest = DocumentSignRequest.builder()
                .planId(PLAN_ID)
                .application(APPLICATION_NAME)
                .policyNumber(paMainInfo.getInsurerPolicyNo())
                .specifyYear(String.valueOf(ld.getYear()))
                .policyType(POLICY_TYPE)
                .files(input)
                .build();

        RestTemplate restTemplate = new RestTemplateBuilder().build();
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));
        headers.set(AUTHORIZATION_HEADER, authorizationHeader);
        HttpEntity<DocumentSignRequest> requestEntity = new HttpEntity<>(documentSignRequest, headers);

        try {
            return handleResponseSignDoc(restTemplate, requestEntity).map(DocumentSignResponse::getFile).orElse(null);
        } catch (HttpClientErrorException ex) {
            // If access token is expired, retry 1 more time with new access token
            if (ex.getStatusCode() == HttpStatus.UNAUTHORIZED) {
                accessToken = authenticate(clientId, clientSecret).getAccessToken();
                authorizationHeader = MessageFormat.format("{0} {1}", cache.get(CACHE_ACCESS_TOKEN_TYPE), accessToken);
                headers.set(AUTHORIZATION_HEADER, authorizationHeader);
                requestEntity = new HttpEntity<>(documentSignRequest, headers);
                return handleResponseSignDoc(restTemplate, requestEntity).map(DocumentSignResponse::getFile).orElse(null);
            }
            throw ex;
        }
    }

    private Optional<DocumentSignResponse> handleResponseSignDoc(RestTemplate rest, HttpEntity<DocumentSignRequest> requestEntity) throws JsonProcessingException {
        return Optional.ofNullable(rest.postForObject(documentEndpoint, requestEntity, String.class))
                .map(StringEscapeUtils::unescapeJson)
                .map(it -> it.substring(1, it.length() - 1))
                .map(it -> {
                    ObjectMapper objectMapper = new ObjectMapper();
                    try {
                        return objectMapper.readValue(it, DocumentSignResponse.class);
                    } catch (JsonProcessingException e) {
                        return null;
                    }
                });
    }

    private Optional<String> getCacheAccessToken() {
        Instant tokenExpireAt = (Instant) cache.get(CACHE_TOKEN_EXPIRE_AT);
        if (tokenExpireAt == null) {
            return Optional.empty();
        }
        if (Instant.now().isAfter(tokenExpireAt)) {
            cache.remove(CACHE_ACCESS_TOKEN);
            cache.remove(CACHE_TOKEN_EXPIRE_AT);
            cache.remove(CACHE_ACCESS_TOKEN_TYPE);
            return Optional.empty();
        }
        return Optional.ofNullable((String) cache.get(CACHE_ACCESS_TOKEN));
    }

    private TokenResponse authenticate(String clientId, String clientSecret) {
        MultiValueMap<String, String> tokenRequest = new LinkedMultiValueMap<>();
        tokenRequest.add("scope", SCOPE);
        tokenRequest.add("client_id", clientId);
        tokenRequest.add("client_secret", clientSecret);
        tokenRequest.add("grant_type", GRANT_TYPE);

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
        headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));

        HttpEntity<MultiValueMap<String, String>> requestEntity = new HttpEntity<>(tokenRequest, headers);

        Instant requestTokenAt = Instant.now();
        return Optional.ofNullable(new RestTemplateBuilder().additionalMessageConverters(new FormHttpMessageConverter()).additionalMessageConverters(new MappingJackson2HttpMessageConverter()).build().postForObject(tokenEndpoint, requestEntity, TokenResponse.class))
                .map(it -> {
                    Instant expiresAt = requestTokenAt.plus(Duration.ofMinutes(it.getExpiresInMin()));
                    cache.put(CACHE_ACCESS_TOKEN, it.getAccessToken());
                    cache.put(CACHE_TOKEN_EXPIRE_AT, expiresAt);
                    cache.put(CACHE_ACCESS_TOKEN_TYPE, it.getTokenType());
                    return it;
                }).orElse(null);
    }
}