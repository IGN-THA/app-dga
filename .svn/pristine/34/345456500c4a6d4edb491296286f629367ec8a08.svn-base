package com.docprocess.component;

import com.docprocess.constant.PdfQueueProcessingStatus;
import com.docprocess.manager.S3BucketManager;
import com.docprocess.pojo.PdfGenerationQueueResponse;
import com.docprocess.pojo.PdfGenerationRequest;
import com.docprocess.service.PdfGenerationService;
import com.docprocess.service.TemplateService;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.core.Single;
import io.reactivex.rxjava3.schedulers.Schedulers;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jms.annotation.JmsListener;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.stereotype.Component;

import java.io.File;
import java.text.MessageFormat;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.Locale;

@Component
public class PdfWorker {
    private final PdfGenerationService pdfGenerationService;
    private final JmsTemplate jmsTemplate;
    private final S3BucketManager s3Mgr;
    private final String s3DocumentBucketName;

    @Autowired
    private ObjectMapper mapper;

    @Autowired
    private TemplateService templateService;

    public PdfWorker(PdfGenerationService pdfGenerationService, JmsTemplate jmsTemplate, S3BucketManager s3Mgr, String s3DocumentBucketName) {
        this.pdfGenerationService = pdfGenerationService;
        this.jmsTemplate = jmsTemplate;
        this.s3Mgr = s3Mgr;
        this.s3DocumentBucketName = s3DocumentBucketName;
    }

    @JmsListener(destination = "pdf.generation.request")
    public void processPdfGenerationRequest(PdfGenerationRequest message) {

        Observable.fromIterable(pdfGenerationService.getPendingTemplate(message.getRequestId()))
                .observeOn(Schedulers.io())
                .map(template ->{
                    LinkedHashMap<String,Object> templateJson = mapper.readValue(new File(
                            templateService.getMessageType("i18n.MotorCar")), new TypeReference<LinkedHashMap<String,Object>>() {
                    });
                    Locale locale = getLocale(template);
                    LinkedHashMap<String,Object> localMap =  (LinkedHashMap<String,Object>) templateJson.get(message.getLocale().toUpperCase());
                    return pdfGenerationService.generatePdfFromTemplate(template, message.getRequestId(), message.getContext(),locale, localMap);
                })
                .lastElement()
                .toSingle()
                .map(__ -> pdfGenerationService.finalizeRenderedFolder(message.getRequestId()))
                .doOnSuccess(renderedFolder -> jmsTemplate.convertAndSend("pdf.upload.request", renderedFolder.getAbsolutePath()))
                .doOnError(__ -> pdfGenerationService.cleanupIntermediaryFolder(message.getRequestId()))
                .subscribe();
    }

    public Locale getLocale(File file){
        String baseName = FilenameUtils.getBaseName(file.getName());
        return new Locale(file.getName().substring(baseName.length() - "**".length() ,baseName.length()));
    }

    @JmsListener(destination = "pdf.upload.request")
    public void processPdfUploadRequest(String renderedFolderPath) {
        Single.just(renderedFolderPath)
                .observeOn(Schedulers.io())
                .map(File::new)
                // TODO: Uncomment this after testing
                .flatMap(folder -> s3Mgr
                        .uploadDirectory(s3DocumentBucketName, MessageFormat.format("validate/quoteSlip/{0}", folder.getName()), folder)
                        .doOnSuccess(__ -> pdfGenerationService.finalizeUpdatedFolder(folder.getName()))
                )
                .subscribe();
    }

}
